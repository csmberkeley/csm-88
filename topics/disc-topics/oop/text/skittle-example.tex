As a starting example, consider the classes {\tt Skittle} and {\tt Bag}, which
will be used to represent a single piece of Skittles candy and a bag of Skittles
respectively.

\begin{lstlisting}
class Skittle:
    """A Skittle object has a color to describe it."""
    def __init__(self, color):
        self.color = color

class Bag:
    """A Bag is a collection of Skittles. All bags share the
    number of Bags ever made (sold) and each bag keeps track of
    its Skittles in a list.
    """
    number_sold = 0

    def __init__(self):
        self.skittles = []
        Bag.number_sold += 1

    def tag_line(self):
        """Print the Skittles tag line."""
        print("Taste the rainbow!")

    def print_bag(self):
        print([s.color for s in self.skittles])

    def take_skittle(self):
        """Take the first skittle in the bag (from the front of
        the skittles list).
        """
        return self.skittles.pop(0)

    def add_skittle(self, s):
        """Add a skittle to the bag."""
        self.skittles.append(s)
\end{lstlisting}

In this example, we have the attribute {\tt number\_sold}, which is a class
attribute. Also, you see this strange method called {\tt \_\_init\_\_}. That is
called when you make a new instance of the class. So, if you write {\tt a =
Bag()}, that makes a new instance of the Bag class (calling {\tt \_\_init\_\_}
to do so) and then returns {\tt self}, which you can think of as a dictionary
that holds all of the attributes of the object.

To make a new class attribute, you use the name of the class with dot notation:
{\tt Bag.new\_var = 10} makes a new class attribute {\tt new\_var} in the Bag
class and assigns it the value of {\tt 10}. To make a new instance attribute,
you use the name of the instance attribute: {\tt a.new\_var2 = 10}. Attribute
lookup works similarly to environment diagrams. You look to see if some instance
attribute has that name. If it doesn't, then you look up the name in the class
attributes.

