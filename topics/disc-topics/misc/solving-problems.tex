\section*{Solving Problems}

\begin{quote} Based on original research by
\href{http://dx.doi.org/10.1145/2858036.2858252}{Loksa, Ko, et al.}
\end{quote}

Note that this advice may not make sense until you start solving problems on 
your own. As you work through your first assignments, try referencing
this guide.

\subsection*{Reinterpret the problem prompt}

Read \emph{and reinterpret} the question. Usually, we begin with a description
of the problem to be solved. What's important is not just reading the problem,
but thinking critically about the implications of the details in the problems
and clear up any ambiguities. When we jump into coding directly without first
thinking through the problem and posing questions for ourselves, we often run
into scenarios where we get stuck and need to ask ourselves, ``What should I
put here?'' or ``What is the right loop end condition?'' This increases the
cognitive load by requiring us to context-switch and remove ourselves from the
problem while we answer a side question.

A couple concrete starting questions to ask yourself on any problem include:

\begin{itemize}
\item What is the \textbf{domain} (input) and \textbf{range} (output) of the
program?
\item Restate the intended behavior of the program in your own words.
\item How will the values in this program change as the program executes?
\end{itemize}

Verify your understanding by studying the doctests. In computer science, the
mental representation for a problem is often closely related to its solution.

\textbf{Big hints are always given away in the doctest!} The doctests inform us
about the shape and format of the solution. If we look closely enough for the
patterns in the doctest, we'll often expose details in the structure of how the
problem is meant to be solved.

Although they provide many hints, the doctests are not exhaustive and they
usually don't show the most important cases. Develop examples that cover at
least the following situations:

\begin{itemize}
\item What's the smallest or simplest possible input I could give to this
function?
\item Is there a similar small input that is \emph{invalid} for this problem?
How is it related to or different from the earlier case?
\item Can we come up with any larger inputs to the program that are related to
or rely on smaller cases? The idea is to come up with some of the subproblems
we might have to solve with recursion or other techniques.
\end{itemize}

\subsection*{Search for analogous problems}

Does this problem look similar to something you've seen before? Armed with your
experience from homework, lab, and discussion, develop a general idea of how to
solve the problem.

Once we've identified a similar problem, we can then extract the general
strategy for solving the problem. While details are useful, copy-and-pasting
the solution from the analogous problem usually won't get us very far. Instead,
verbalize the code and reinterpret it in English by asking, ``What's the
purpose of including this code?''

\subsection*{Adapting previous solutions}

Implement a solution by applying the problem solving techniques you've learned
alongside your experience with analogous problems. With recursion, for example,
it helps to try to follow the steps of finding a base case, identifying the
recursive calls, and then combining the results. However, the particular
implementation in code will depend upon the specific details of the problem.

It might not be fully correct, but that's fine and completely normal; refining
mental representations of the problem takes time and practice.

\subsection*{Evaluating solutions}

Analyze and test the resulting implementation. We'd like to answer two central
questions:

\begin{enumerate}
\item Is my approach on the right track? If not, maybe we should consider
another analogous problem.
\item If my approach is in the right direction, \textbf{let's evaluate} and
verify the correctness of the solution.
\end{enumerate}

\textbf{To improve our code, we just need to ask ourselves the right
questions.} What input would break the program? Think like Python: run through
the code step-by-step until there's a problem. We have examples of what the
output should look like, so make sure the actual result matches expectations.

If the results aren't consistent, let's try to identify why and make
adjustments by asking more specific questions. Where is the root of problem?
Let's trace back through the code to find the source of the problem. Then, once
we've found the problem, let's try the same approach of searching for analogous
problems, except on this one, particular subproblem.
