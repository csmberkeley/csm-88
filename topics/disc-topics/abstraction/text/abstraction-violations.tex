Notice how we did not need to know how the constructors and selectors in the
previous section were implemented in order to use them. This is what we mean by
the \emph{implementation} and \emph{use} of an abstract data type being
separate.  In fact, you should never assume anything about how the constructors
and selectors for an abstract data type are implemented. Doing so is called a
\define{data abstraction violation}.

As an example, here is one implemenation for the {\tt rational} constructor.

\begin{lstlisting}
def rational(n, d):
    return [n, d]
\end{lstlisting}

Given this constructor, the following would be considered a data abstraction
violation:

\begin{lstlisting}
>>> frac1 = rational(3, 4)
>>> frac2 = rational(5, 6)
>>> frac1[0] * frac2[0]
15
\end{lstlisting}

This is because we assumed rationals were represented as lists instead of
accessing their elements using the selectors.
